package Communication

import (
	. "encoding/json"
	"fmt"
	. "strings"
	"network"
)

func main() {
	fmt.Println("hei")
}
func Channels_init() {
	
	slaveToCommSlaveChan := make(chan Slave)    				//"sla"
	slaveToCommOrderReceivedChan := make(chan []int) 			//"ore"
	slaveToCommOrderExecutedChan := make(chan []int) 			//"oex"
	slaveToCommOrderConfirmedReceivedChan := make(chan []int)   //"ocr"   
	slaveToCommOrderConfirmedExecutuinChan := make(chan []int)	//"oce"

	//Master
	masterToCommOrderListChan := make(chan [][]int)          	//"exo"
	masterToCommImMasterChan := make(chan string)           	//"iam"
	masterToCommReceivedConfirmationChan := make(chan []int) 	//"rco"
	masterToCommExecutedConfirmationChan := make(chan []int) 	//"eco"
	
	//communication channels
	commToMasterSlaveChan := make(chan Slave)         			//"sla"
	commToMasterOrderReceivedChan := make(chan []int)			//"ore"
	commToMasterOrderExecutedChan := make(chan []int) 			//"oex"
	commToMasterOrderConfirmedReceivedChan := make(chan []int)  //"ocr"
	commToMasterOrderConfirmedExecutionChan := make(chan []int) //"oce"
	
	commToSlaveOrderListChan := make(chan [][]int)              //"exo"
	commToSlaveImMasterChan := make(chan string)           		//"iam"
	commToSlaveReceivedConfirmationChan := make(chan []int)		//"rco"
	commToSlaveExecutedConfirmationChan := make(chan []int)		//"eco"
	
	newExternalList := make(chan [][]int)
	slaveToStateMChan := make(chan int) //send input to statemachine
	//network
	commToNetwork := make(chan []byte)
	networkToComm := make(chan []byte)
}

//Master
func Send_order(externalOrderList [][]int, commToNetwork chan []byte) { //send exectuionOrderList
	byteOrder, err := Marshal(externalOrderList)
	prefix, err := Marshal("exo")
	commToNetwork <- append(prefix, byteOrder...)
}

func Send_im_master(message string, commToNetwork chan []byte) {//send I am master
	byteMessage, err := Marshal(message)
	prefix, err := Marshal("iam")
	commToNetwork <- append(prefix, byteMessage...)
}
func Send_received_confirmation(order[]int, commToNetwork chan []byte) {
	byteMessage, err := Marshal(order)
	prefix, err := Marshal("rco")
	commToNetwork <- append(prefix, byteMessage...)
}
	
func Send_executed_confirmation(order []int, commToNetwork chan []byte) {
	byteMessage, err := Marshal(order)
	prefix, err := Marshal("eco")
	commToNetwork <- append(prefix, byteMessage...)
}

//Slave
func Send_slave(s Slave, commToNetwork chan []byte) {
	byteSlave, err := Marshal(s)
	prefix, err := Marshal("sla")
	commToNetwork <- append(prefix, byteSlave...)
}    

func Send_order_received(order []int, commToNetwork chan []byte) {
	byteMessage, err := Marshal(order)
	prefix, err := Marshal("ore")
	commToNetwork <- append(prefix, byteMessage...)
} 

func Send_order_executed(order []int, commToNetwork chan []byte) {
	byteMessage, err := Marshal(order)
	prefix, err := Marshal("oex")
	commToNetwork <- append(prefix, byteMessage...)
} 

func Send_order_confirmed_received(order []int, commToNetwork chan []byte) {
	byteMessage, err := Marshal(order)
	prefix, err := Marshal("ocr")
	commToNetwork <- append(prefix, byteMessage...)
}        

func Send_order_confirmed_executed(order []int, commToNetwork chan []byte) {
	byteMessage, err := Marshal(order)
	prefix, err := Marshal("oce")
	commToNetwork <- append(prefix, byteMessage...)
}


func Decrypt_message(message []byte) {
	switch {
	//Master
	case string(message[1:4] == "sla"): 
		noPrefix = message[5:]
		var s Slave 
		err := UnMarshal(noPrefix, &s)
		commToMasterSlaveChan <- s

	case string(message[1:4]) == "ore": 
		noPrefix = message[5:]
		order := make([]int, 2)
		err := UnMarshal(noPrefix, &order)
		commToMasterOrderReceivedChan <- order

	case string(message[1:4]) == "oex": 
		noPrefix = message[5:]
		order := make([]int, 2)
		err := UnMarshal(noPrefix, &order)
		ommToMasterOrderExecutedChan <- order

	case string(message[1:4]) == "ocr": 
		noPrefix = message[5:]
		order := make([]int, 2)
		err := UnMarshal(noPrefix, &order)
		commToMasterOrderConfirmedReceivedChan <- order

	case string(message[1:4]) == "oce": 
		noPrefix = message[5:]
		order := make([]int, 2)
		err := UnMarshal(noPrefix, &order)
		commToMasterOrderConfirmedExecutionChan <- order

	//Slave
	case string(message[1:4]) == "exo": 
		noPrefix = message[5:]
		externalOrderList := make([][]int, FLOORS)
		err := Unmarshal(message, &externalOrderList)
		commToSlaveOrderListChan <- externalOrderList

	case string(message[1:4]) == "iam": 
		noPrefix = message[5:]
		commToSlaveImMasterChan <- noPrefix

	case string(message[1:4]) == "rco": 
		noPrefix = message[5:]
		order := make([]int, 2)
		err := UnMarshal(noPrefix, &order)
		commToSlaveReceivedConfirmationChan <- order

	case string(message[1:4]) == "eco": 
		noPrefix = message[5:]
		order := make([]int, 2)
		err := UnMarshal(noPrefix, &order)
		commToSlaveExecutedConfirmationChan <- order	
}
func Select_send(commToNetwork chan []byte) {

	for {
		select {
			//Master
			case externalOrderList <- masterToCommOrderListChan: 
				Send_order(externalOrderList, commToNetwork)
			case message <- masterToCommImMasterChan:
				Send_im_master(message, commToNetwork)
			case order <- masterToCommReceivedConfirmationChan:
				Send_received_confirmation(order, commToNetwork) 
			case order <- masterToCommExecutedConfirmationChan:
				Send_executed_confirmation(order, commToNetwork) 
			//Slave
			case slave <- slaveToCommSlaveChan:
				Send_slave(slave, commToNetwork)
			case order <- slaveToCommOrderReceivedChan:
				Send_order_received(order, commToNetwork)
			case order <- slaveToCommOrderConfirmedReceivedChan:
				Send_order_executed(order, commToNetwork)
			case order <- slaveToCommOrderConfirmedReceivedChan:
				Send_order_confirmed_received(order, commToNetwork) 
			case order <- slaveToCommOrderConfirmedExecutuinChan:
				Send_order_confirmed_executed(order, commToNetwork)
		}
	}
}
func Select_receive(networkToComm) {
	var barr []byte
	for {
		select {
			case barr <- commToMasterSlaveChan:
				      		
			case barr <- commToMasterOrderReceivedChan:		
	
			case barr <- commToMasterOrderExecutedChan:			
	
			case barr <- commToMasterOrderConfirmedReceivedChan:
	
			case barr <- commToMasterOrderConfirmedExecutionChan:
	
			case barr <- commToSlaveOrderListChan:       

			case barr <- commToSlaveImMasterChan:
			     
			case barr <- commToSlaveReceivedConfirmationChan:

			case barr <- commToSlaveExecutedConfirmationChan:
		}
		Dectrypt_message(barr)
	}
}
